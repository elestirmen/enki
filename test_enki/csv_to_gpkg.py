import argparse
from pathlib import Path
from typing import Iterable, List, Optional, Sequence, Tuple

import numpy as np
import pandas as pd


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Convert Enki inference CSV outputs into a GeoPackage with georeferenced "
            "bounding boxes and center points."
        )
    )
    parser.add_argument(
        "--csv-path",
        required=True,
        type=Path,
        help="Path to the predictions CSV generated by run_npz_inference.py.",
    )
    parser.add_argument(
        "--npz-path",
        required=True,
        type=Path,
        help=(
            "NPZ file used during inference. Metadata inside the NPZ is used to locate "
            "the reference raster automatically."
        ),
    )
    parser.add_argument(
        "--reference-raster",
        type=Path,
        help=(
            "Optional raster path to use for georeferencing. If omitted, the script "
            "attempts to read the original raster path from NPZ metadata."
        ),
    )
    parser.add_argument(
        "--gpkg-path",
        type=Path,
        help=(
            "Destination GeoPackage path. Defaults to <csv_path_stem>_detections.gpkg "
            "next to the CSV file."
        ),
    )
    parser.add_argument(
        "--include-classes",
        nargs="+",
        default=["Positive"],
        help=(
            "List of class names to include in the GeoPackage. "
            "Defaults to only 'Positive'. Use 'ALL' to include every class."
        ),
    )
    parser.add_argument(
        "--min-confidence",
        type=float,
        default=0.5,
        help="Minimum confidence required to keep a detection (default: 0.5).",
    )
    return parser.parse_args()


def load_npz_metadata(npz_path: Path) -> Optional[dict]:
    with np.load(npz_path, allow_pickle=True) as data:
        if "_metadata" in data.files:
            return data["_metadata"].item()
    return None


def resolve_reference_raster(
    npz_path: Path, metadata: Optional[dict], override: Optional[Path]
) -> Optional[Path]:
    candidates: List[Path] = []
    if override is not None:
        candidates.append(override)
    if metadata:
        source_path = metadata.get("input_path")
        if isinstance(source_path, str) and source_path:
            candidates.append(Path(source_path))
            candidates.append(npz_path.parent / Path(source_path).name)
    for candidate in candidates:
        if candidate and candidate.exists():
            return candidate
    return None


def load_georeferencing(raster_path: Path):
    import rasterio

    with rasterio.open(raster_path) as src:
        return src.transform, src.crs


def project_boxes_to_geometries(
    detections: pd.DataFrame, transform
) -> Tuple[Iterable["Polygon"], Iterable["Point"], List[float], List[float]]:
    import rasterio.transform
    from shapely.geometry import Point, box

    polygons = []
    points = []
    center_xs: List[float] = []
    center_ys: List[float] = []

    for row in detections.itertuples(index=False):
        top = float(row.top)
        left = float(row.left)
        bottom = float(row.bottom)
        right = float(row.right)

        minx, maxy = rasterio.transform.xy(transform, top, left, offset="ul")
        maxx, miny = rasterio.transform.xy(
            transform, bottom - 1, right - 1, offset="lr"
        )

        polygons.append(box(minx, miny, maxx, maxy))

        center_col = left + (right - left) / 2.0
        center_row = top + (bottom - top) / 2.0
        center_x, center_y = transform * (center_col, center_row)
        points.append(Point(center_x, center_y))
        center_xs.append(center_x)
        center_ys.append(center_y)

    return polygons, points, center_xs, center_ys


def export_geopackage(
    detections: pd.DataFrame,
    transform,
    crs,
    gpkg_path: Path,
) -> None:
    if detections.empty:
        print("No detections remaining after filtering; skipping GeoPackage export.")
        return

    try:
        import geopandas as gpd
    except ImportError as exc:
        raise RuntimeError(
            "geopandas is required for GeoPackage export. "
            "Install it with `pip install geopandas`."
        ) from exc

    polygons, points, center_xs, center_ys = project_boxes_to_geometries(
        detections, transform
    )

    gpkg_path.parent.mkdir(parents=True, exist_ok=True)

    polygon_df = detections.copy()
    polygon_df["center_x"] = center_xs
    polygon_df["center_y"] = center_ys
    gdf_polygons = gpd.GeoDataFrame(polygon_df, geometry=polygons, crs=crs)
    gdf_polygons.to_file(gpkg_path, layer="detections_tiles", driver="GPKG")

    gdf_points = gpd.GeoDataFrame(
        polygon_df.drop(columns="geometry", errors="ignore"),
        geometry=points,
        crs=crs,
    )
    gdf_points.to_file(gpkg_path, layer="detections_points", driver="GPKG", mode="a")


def main() -> None:
    args = parse_args()

    metadata = load_npz_metadata(args.npz_path)
    reference_raster = resolve_reference_raster(
        args.npz_path, metadata, args.reference_raster
    )
    if reference_raster is None:
        raise FileNotFoundError(
            "Could not determine reference raster. Please provide --reference-raster."
        )

    transform, crs = load_georeferencing(reference_raster)

    if not args.csv_path.exists():
        raise FileNotFoundError(f"CSV file not found: {args.csv_path}")

    detections = pd.read_csv(args.csv_path)
    required_columns = {"top", "left", "bottom", "right", "predicted_class", "confidence"}
    missing = required_columns - set(detections.columns)
    if missing:
        raise ValueError(f"CSV is missing required columns: {', '.join(sorted(missing))}")

    include_classes = args.include_classes
    if len(include_classes) == 1 and include_classes[0].upper() == "ALL":
        include_classes = detections["predicted_class"].unique().tolist()

    filtered = detections[
        (detections["predicted_class"].isin(include_classes))
        & (detections["confidence"] >= args.min_confidence)
    ].copy()

    if filtered.empty:
        print(
            "No rows survived filtering. Try lowering --min-confidence or adjusting --include-classes."
        )

    gpkg_path = (
        args.gpkg_path
        if args.gpkg_path is not None
        else args.csv_path.with_name(f"{args.csv_path.stem}_detections.gpkg")
    )

    export_geopackage(filtered, transform, crs, gpkg_path)
    print(f"GeoPackage written to {gpkg_path}")


if __name__ == "__main__":
    main()
